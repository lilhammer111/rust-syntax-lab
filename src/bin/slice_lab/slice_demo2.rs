fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}

fn first_word(s: &String) -> &str {
    // 这段代码看似简单实则不简单，这里面蕴含了两个值得思考的地方：

    // 1. 哪些类型可以被切片？
    // 在first_word函数中，上述代码使用了&s[..1]的取切片的操作，那我们就要确保变量s是一个可被取切片的类型，
    // 而决定一个类型是否可被取切片，本质是看这个类型是否实现了这两个Trait，即std::ops::Index和std::ops::IndexMut，
    // 在Rust标准库中就有两个常见的类型实现了这两个Trait，一是&str字符串切片类型，二是&[T]数组类型，
    // 因此我们传入first_word的参数就必须得是上述的一种情况，这里的本意应该是想传入一个&str字符串类型，
    // 但实际上却传的是&String类型。这就引发了第二个问题。

    // 2. 为什么传&String也能成功地取到切片呢?
    // 这涉及到了Rust的另一个机制，自动解引用Autoderef，什么是自动解引用？以函数调用为例，
    // 当我们调用一个函数并为这个函数传递传参时（如果这个函数有参数），
    // 就要求咱们传入的参数类型必须和函数定义的参数类型一致，Rust编译器会在这里进行类型是否匹配的检查，
    // 当然，类型检查无处不在，但Rust具体是如何去做的呢？
    // 假如某个类型的引用不直接和参数要求的类型匹配，Rust就会检查传入的类型在经过自动解引用后是否能和参数类型匹配上，
    // 也即，传入的类型是否实现了Deref Trait，比如说某个类型T对于Deref Trait的具体实现就是将类型T转成U类型，
    // 那这个时候自动解引用机制就能把&T类型的函数入参转成&U类型，而函数如果要的就是&U类型，那类型就匹配上了。
    // 当前例子就是这种场景，在对s这个入参进行取切片的操作时，就需要变量s是可以取切片的类型，
    // 即s的类型得是第一个问题中提及的实现了std::ops::Index Trait的类型，我们才可以进行取切片的操作，
    // 否则就会报类型不匹配。这里的s是&String类型，但是因为自动解引用机制，
    // Rust编译器会“尽一切努力”去为s解引用出一个能够取切片的类型，而比较美好的一件事就是，
    // String类型确实实现了Deref Trait，并且他对这个Trait的实现恰恰就是从&String转成&str，
    // 因此，在这里一个&String类型的变量s成功地取了切片&s[..1]。
    &s[..1]
}